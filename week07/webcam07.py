"""
To use this script, you first have to generate an image with the object you
want to track.
Give the image the name 'refs.jpg' and save it to the same location as this
script
"""

import sys

# TODO: Read the head comment
import cv2
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
from numpy.fft import fft2, ifft2

sys.path.append("../..")
from utilities.webcam_control import Webcam

matplotlib.use("Qt5agg")

# Parameter
settings = {
    "frame_width": 2048,
    "frame_height": 1536,
    "exposure": -4,
    "gain": 0,
}  # manual camera settings
# settings_file = 'settings.txt'  # file name with settings
# (generated by 'get_settings.py')

downsampling_factor = 1  # downsampling factor (increases speed, but data is lost)

# Open video stream
camera = Webcam(port=0, settings=settings, downscale=downsampling_factor)

# Load reference image and compute FFT
fwd = int(np.ceil(settings["frame_width"] / downsampling_factor))
fhd = int(np.ceil(settings["frame_height"] / downsampling_factor))
r = cv2.imread("refs.jpg") / 255
if r.ndim > 2:
    r = np.mean(r, 2)
(rh, rw) = r.shape
pdh = (fhd - rh) // 2
pdw = (fwd - rw) // 2
ref = np.zeros((fhd, fwd))
ref[pdh : pdh + rh, pdw : pdw + rw] = r
ref = fft2(ref, (fhd, fwd))

# Initialize plot
fig, ax = plt.subplots(num=1, clear=True, constrained_layout=True)
p = ax.imshow(np.outer(np.arange(fhd), np.arange(fwd)) / (fwd * fhd), cmap="viridis")
fig.canvas.mpl_connect("close_event", camera.stop_camera)
fig.colorbar(p, ax=ax)

print("Start displaying images from camera")
while 1:
    # Capture frame-by-frame
    ret, frame = camera.get_frame()
    if not ret:
        break

    # Preprocessing
    f = frame.copy()
    # f = np.rot90(f, k=2)  # rotate image by 180 degrees

    # Phase correlation
    g = np.array(np.mean(f, 2), dtype="uint8") / 255  # normalize
    G = fft2(g)
    Z = ref * np.conjugate(G)
    r = ifft2(Z / (np.abs(Z) + 1e-9))

    idx = np.squeeze(np.array(np.where(r == r.max())))
    print(idx)
    r = abs(r)
    r = r - r.min()
    r = r / r.max()
    r = np.array(r, dtype="uint8")

    # Update phase correlation plot
    p.set_data(r)
    fig.canvas.draw_idle()
    fig.canvas.start_event_loop(0.001)

    # Update image
    cv2.imshow("preview", f)

# When everything done, release the capture
camera.close()
plt.close(fig)
print("Closed camera")
