"""
To use this script, you first have to generate an image with the object you
want to track.
Give the image the name 'refs.jpg' and save it to the same location as this
script
"""

import sys

# TODO: Read the head comment
import cv2
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
from numpy.fft import fft2, ifft2

sys.path.append("../..")
from utilities.webcam_control import Webcam

matplotlib.use("Qt5agg")

# Parameter
settings = {
    "frame_width": 2048,
    "frame_height": 1536,
    "exposure": -4,
    "gain": 0,
}  # manual camera settings
# settings_file = 'settings.txt'  # file name with settings
# (generated by 'get_settings.py')

downsampling_factor = 1  # downsampling factor (increases speed, but data is lost)

# Open video stream
camera = Webcam(port=0, settings=settings, downscale=downsampling_factor)

# Load reference image and compute FFT
fwd = int(np.ceil(settings["frame_width"] / downsampling_factor))
fhd = int(np.ceil(settings["frame_height"] / downsampling_factor))
ref_img = cv2.imread("refs.jpg") / 255
if ref_img.ndim > 2:
    ref_img = np.mean(ref_img, 2)
(rh, rw) = ref_img.shape
pdh = (fhd - rh) // 2
pdw = (fwd - rw) // 2
ref = np.zeros((fhd, fwd))
ref[pdh : pdh + rh, pdw : pdw + rw] = ref_img
ref = fft2(ref, (fhd, fwd))

# Initialize plot
fig, ax = plt.subplots(num=1, clear=True, constrained_layout=True)
p = ax.imshow(np.outer(np.arange(fhd), np.arange(fwd)) / (fwd * fhd), cmap="viridis")
fig.canvas.mpl_connect("close_event", camera.stop_camera)
fig.colorbar(p, ax=ax)

r = np.zeros_like(ref, float)
print("Start displaying images from camera")
while 1:
    # Capture frame-by-frame
    ret, frame = camera.get_frame()
    if not ret:
        break

    # Preprocessing
    f = frame.copy()
    # f = np.rot90(f, k=2)  # rotate image by 180 degrees

    # Phase correlation
    # TODO make image grayscale and normalize it

    # TODO calculate r = ifft2(Ga*conj(Gb)/abs(Ga*conj(Gb)))

    # TODO calculate shift and display in console

    # TODO Normalize r for displaying in plot

    # Update phase correlation plot
    p.set_data(r)
    fig.canvas.draw_idle()
    fig.canvas.start_event_loop(0.001)

    # Update image
    cv2.imshow("preview", f)

# When everything done, release the capture
camera.close()
plt.close(fig)
print("Closed camera")
